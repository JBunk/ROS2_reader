#include "FibActionServer.hpp"
#include "rclcpp/rclcpp.hpp"                // Needed for nodes
#include "rclcpp_action/rclcpp_action.hpp"  // needed for actions

// the location of our custom action.
// the hpp generated by ROS as a underscore (_) before every capital, expect the first:
// for example: /my/path/MyAction.action become /my/path/my_action.action
#include "custom_interfaces/action/fibonacci.hpp"

using namespace std::placeholders;

// constructor:
FibActionServer::FibActionServer(): Node("fibonacci_action_server") {


    this->action_server_ = rclcpp_action::create_server<FibAction>(
        this,
        "fibonacci",
        std::bind(&FibActionServer::handle_goal, this, _1, _2),
        std::bind(&FibActionServer::handle_cancel, this, _1),
        std::bind(&FibActionServer::handle_accepted, this, _1));
}

rclcpp_action::GoalResponse FibActionServer::handle_goal(
    const rclcpp_action::GoalUUID & uuid, // uuid means universally unique identifier
    std::shared_ptr<const FibAction::Goal> goal
){
    RCLCPP_INFO(this->get_logger(), "Received goal request with order %d", goal->order);
    // we are not using the uuid. If you dont use a parameter you will get a warning.
    // the parameters are predefined by ROS, so we cant remove the uuid parameter.
    // So we supress the warning by casting the uuid variable to void:
    (void)uuid;
    // for more information about casting to void see: https://stackoverflow.com/questions/34288844/what-does-casting-to-void-really-do
    // UUID is a way to generate (pratically) unique identifiers.
    // See for more information: https://en.wikipedia.org/wiki/Universally_unique_identifier
    // and about how unique they are: 
    // https://stackoverflow.com/questions/1155008/how-unique-is-uuid
    // and with math: https://towardsdatascience.com/are-uuids-really-unique-57eb80fc2a87


    // to show an example of rejecting we reject fibonacy sequences that are over 9000:
    if (goal->order > 9000) {
      return rclcpp_action::GoalResponse::REJECT;
    }
    return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;
}

rclcpp_action::CancelResponse FibActionServer::handle_cancel(
    const std::shared_ptr<GoalHandleFib> goal_handle
){
    RCLCPP_INFO(this->get_logger(), "Received request to cancel goal");
    // we are not using the parameter goal_handel
    // to supress warnings we cast it to void:
    (void)goal_handle;
    return rclcpp_action::CancelResponse::ACCEPT;
}

void FibActionServer::handle_accepted(const std::shared_ptr<GoalHandleFib> goal_handle){
    // this function needs to return quickly to avoid blocking the executor, so spin up a new thread
    std::thread{std::bind(&FibActionServer::execute, this, _1), goal_handle}.detach();
}

void FibActionServer::execute(const std::shared_ptr<GoalHandleFib> goal_handle){
    RCLCPP_INFO(this->get_logger(), "Executing goal");

    rclcpp::Rate loop_rate(1); // loop frequency

    const auto goal = goal_handle->get_goal();
    auto feedback = std::make_shared<FibAction::Feedback>();
    auto & sequence = feedback->partial_sequence;
    sequence.push_back(0);
    sequence.push_back(1);
    auto result = std::make_shared<FibAction::Result>();

    for (int i = 1; (i < goal->order) && rclcpp::ok(); ++i) {
        // Check if there is a cancel request
        // is_canceling is true if a cancelling message is send.
        if (goal_handle->is_canceling()) { 
            result->sequence = sequence;
            goal_handle->canceled(result); // set is_cancelling to false again
            RCLCPP_INFO(this->get_logger(), "Goal Canceled");
            return;
        }

        // Update sequence
        sequence.push_back(sequence[i] + sequence[i - 1]);

        // Publish feedback
        goal_handle->publish_feedback(feedback);
        RCLCPP_INFO(this->get_logger(), "Publish Feedback");

        // sleep until next loop (see loop_rate at the start of this function)
        loop_rate.sleep();
    }

    // the goal is done (the for loop ended):
    if (rclcpp::ok()) {
      result->sequence = sequence;
      goal_handle->succeed(result);
      RCLCPP_INFO(this->get_logger(), "Goal Succeeded");
    }
}
